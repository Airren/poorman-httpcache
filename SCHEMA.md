# Database Schema

This document describes the database schema for the API key management system.

## Tables

### 1. Users Table
Stores user information, identified by email address.

```sql
CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for performance
CREATE INDEX idx_users_email ON users(email);
```

### 2. Services Table
Defines available services that can be accessed via API keys. Flexible design allows adding new services dynamically.

```sql
CREATE TABLE services (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for performance
CREATE INDEX idx_services_name ON services(name);
```

### 3. API Key Statuses Table
Reference table for valid API key status values. Designed to be extensible for future status types.

```sql
CREATE TABLE api_key_statuses (
    name TEXT PRIMARY KEY,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert initial status values
INSERT INTO api_key_statuses (name, description) VALUES
('unassigned', 'Key generated but not yet assigned to user'),
('assigned', 'Key assigned to user and active'),
('exhausted', 'All quotas for this key are depleted'),
('revoked', 'Key manually revoked/suspended');
```

### 4. API Keys Table
Stores API key strings and their current status. Each key belongs to one user.

```sql
CREATE TABLE api_keys (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    key_string TEXT UNIQUE NOT NULL,
    status TEXT NOT NULL DEFAULT 'unassigned' REFERENCES api_key_statuses(name),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE UNIQUE INDEX idx_api_keys_key_string ON api_keys(key_string);
CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);
CREATE INDEX idx_api_keys_status ON api_keys(status);
```

## Status Values
API key status is enforced by foreign key constraint to the `api_key_statuses` table. Current valid values:
- `unassigned` - Key generated but not yet assigned to user
- `assigned` - Key assigned to user and active
- `exhausted` - All quotas for this key are depleted
- `revoked` - Key manually revoked/suspended

**To add new status values**: Simply insert into `api_key_statuses` table:
```sql
INSERT INTO api_key_statuses (name, description) 
VALUES ('suspended', 'Temporarily suspended by administrator');
```

## Key Format
All API keys are prefixed with `sk-miro-api-` followed by a unique identifier.

### 5. API Key Service Quotas Table
Junction table linking API keys to services with quota tracking. Each key can have quotas for multiple services.

```sql
CREATE TABLE api_key_service_quotas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    api_key_id BIGINT NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    service_id BIGINT NOT NULL REFERENCES services(id) ON DELETE CASCADE,
    initial_quota INTEGER NOT NULL,
    remaining_quota INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(api_key_id, service_id)
);

-- Indexes for performance
CREATE INDEX idx_api_key_service_quotas_api_key_id ON api_key_service_quotas(api_key_id);
CREATE INDEX idx_api_key_service_quotas_service_id ON api_key_service_quotas(service_id);
```

### 6. API Key Service Usage Logs
Audit trail for all API service consumption. Records every usage event with consumption amount and optional request tracking.

```sql
CREATE TABLE api_key_service_usage_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    api_key_id BIGINT NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    service_id BIGINT NOT NULL REFERENCES services(id) ON DELETE CASCADE,
    consumption_amount INTEGER NOT NULL DEFAULT 1,
    request_id TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance and analytics
CREATE INDEX idx_usage_log_api_key_id ON api_key_service_usage_logs(api_key_id);
CREATE INDEX idx_usage_log_service_id ON api_key_service_usage_logs(service_id);
CREATE INDEX idx_usage_log_created_at ON api_key_service_usage_logs(created_at);
CREATE INDEX idx_usage_log_request_id ON api_key_service_usage_logs(request_id);
CREATE INDEX idx_usage_log_api_key_created ON api_key_service_usage_logs(api_key_id, created_at);
```

### 7. API Key Status Events
Timeline of status changes for API keys. Simplified design for easy querying with referential integrity.

```sql
CREATE TABLE api_key_status_events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    api_key_id BIGINT NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    status TEXT NOT NULL REFERENCES api_key_statuses(name),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for timeline queries
CREATE INDEX idx_status_events_api_key_id ON api_key_status_events(api_key_id);
CREATE INDEX idx_status_events_api_key_created ON api_key_status_events(api_key_id, created_at DESC);
```

## Redis Schema (Future High-Performance Layer)

For high-frequency operations, Redis will serve as a caching layer:

### Current Quotas (Hot Data)
```redis
# Pattern: quota:{api_key_id}:{service_id}
# Value: remaining quota count (integer)
# TTL: Optional, or persist until sync
quota:123:456 → "150"
quota:123:457 → "0"
```

### Usage Buffers (Batch Sync)
```redis
# Pattern: usage_buffer:{api_key_id}:{service_id}
# Value: pending consumption amount (integer)
# Used to batch updates before syncing to PostgreSQL
usage_buffer:123:456 → "5"
```

### Key Status Cache
```redis
# Pattern: key_status:{api_key_id}
# Value: current status string
key_status:123 → "assigned"
```

### Service Metadata Cache
```redis
# Pattern: service:{service_id}
# Value: JSON with service details
service:456 → "{\"name\":\"translation\",\"active\":true}"
```

## Query Examples

### Get status timeline for an API key
```sql
SELECT status, created_at 
FROM api_key_status_events 
WHERE api_key_id = $1 
ORDER BY created_at DESC;
```

### Check remaining quotas for a key
```sql
SELECT s.name, q.remaining_quota, q.initial_quota
FROM api_key_service_quotas q
JOIN services s ON s.id = q.service_id
WHERE q.api_key_id = $1;
```

## PostgreSQL Best Practices Applied
Following recommendations from [PostgreSQL wiki](https://wiki.postgresql.org/wiki/Don't_Do_This):

- ✅ Used `TIMESTAMPTZ` instead of `TIMESTAMP` for proper timezone handling
- ✅ Used `BIGINT GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL` 
- ✅ Used `TEXT` and `VARCHAR` without arbitrary length limits
- ✅ Used snake_case naming convention throughout
- ✅ Proper foreign key constraints with CASCADE behavior
- ✅ Used surrogate keys (id columns) for stability and performance over natural keys
- ✅ Implemented extensible enum pattern via reference table instead of rigid CHECK constraints
- ✅ Enforced referential integrity for status values to prevent invalid states

## Notes
- Users are identified solely by email address
- One user can have multiple API keys (1:N relationship)
- Each API key belongs to exactly one user
- Redis layer enables high-performance quota checking and batch updates
- PostgreSQL serves as the authoritative data store
- All audit trails preserved in PostgreSQL for compliance and analytics
