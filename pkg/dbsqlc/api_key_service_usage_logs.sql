CREATE TABLE api_key_service_usage_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    api_key_id BIGINT NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    service_id BIGINT NOT NULL REFERENCES services(id) ON DELETE CASCADE,
    consumption_amount INTEGER NOT NULL DEFAULT 1, -- Aggregated count for the minute
    minute_timestamp TIMESTAMPTZ NOT NULL, -- Truncated to minute boundary
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Updated indexes for minute aggregation
CREATE INDEX idx_usage_log_api_key_id ON api_key_service_usage_logs(api_key_id);
CREATE INDEX idx_usage_log_service_id ON api_key_service_usage_logs(service_id);
CREATE INDEX idx_usage_log_minute_timestamp ON api_key_service_usage_logs(minute_timestamp);
CREATE UNIQUE INDEX idx_usage_log_unique_minute ON api_key_service_usage_logs(api_key_id, service_id, minute_timestamp);

-- New queries for aggregation
-- name: UpsertMinuteUsage :one
INSERT INTO api_key_service_usage_logs (api_key_id, service_id, consumption_amount, minute_timestamp)
VALUES ($1, $2, $3, $4)
ON CONFLICT (api_key_id, service_id, minute_timestamp) 
DO UPDATE SET consumption_amount = api_key_service_usage_logs.consumption_amount + $3
RETURNING consumption_amount;

-- Batch insert usage logs for multiple events
-- name: BatchInsertUsageLogs :copyfrom
INSERT INTO api_key_service_usage_logs (api_key_id, service_id, consumption_amount, minute_timestamp, created_at)
VALUES ($1, $2, $3, $4, $5);
