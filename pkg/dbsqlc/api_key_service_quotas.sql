CREATE TABLE api_key_service_quotas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    api_key_id BIGINT NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    service_id BIGINT NOT NULL REFERENCES services(id) ON DELETE CASCADE,
    initial_quota INTEGER NOT NULL,
    remaining_quota INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(api_key_id, service_id)
);

CREATE INDEX idx_api_key_service_quotas_api_key_id ON api_key_service_quotas(api_key_id);
CREATE INDEX idx_api_key_service_quotas_service_id ON api_key_service_quotas(service_id);

-- API Key Service Quota-related queries

-- Initialize API key service quotas with full quota
-- name: InitializeKeyServiceQuota :one
INSERT INTO api_key_service_quotas (api_key_id, service_id, initial_quota, remaining_quota)
VALUES ($1, $2, $3, $3)
ON CONFLICT (api_key_id, service_id) DO UPDATE SET
    initial_quota = $3,
    remaining_quota = $3,
    updated_at = NOW()
RETURNING *;

-- Batch initialize quotas for all services for a given API key
-- name: BatchInitializeKeyQuotas :copyfrom
INSERT INTO api_key_service_quotas (api_key_id, service_id, initial_quota, remaining_quota)
VALUES ($1, $2, $3, $3);

-- Get API key quotas with service info
-- name: GetAPIKeyQuotas :many
SELECT aksq.*, s.name as service_name
FROM api_key_service_quotas aksq
JOIN services s ON aksq.service_id = s.id
WHERE aksq.api_key_id = $1;

-- Get balance (remaining quota) for an API key by key_string and service_id
-- name: GetBalanceByID :one
SELECT aksq.initial_quota, aksq.remaining_quota
FROM api_key_service_quotas aksq
WHERE aksq.api_key_id = $1 and aksq.service_id = $2;

-- Get balance (remaining quota) for an API key by key_string and service_id
-- name: GetQuota :one
SELECT aksq.initial_quota, aksq.remaining_quota
FROM api_key_service_quotas aksq
JOIN services s ON aksq.service_id = s.id
JOIN api_keys ak ON aksq.api_key_id = ak.id
WHERE ak.key_string = $1 and s.name = $2;


-- Reserve $amount quota for ($api_key, $service_name) by  (decreases by $amount unit)
-- name: ReserveQuota :one
WITH quota_check AS (
    SELECT aksq.id, aksq.remaining_quota, aksq.api_key_id, aksq.service_id
    FROM api_key_service_quotas aksq
    JOIN services s ON aksq.service_id = s.id
    JOIN api_keys ak ON aksq.api_key_id = ak.id
    WHERE ak.key_string = $1 AND s.name = $2 AND ak.status = 'assigned'
)
UPDATE api_key_service_quotas
SET remaining_quota = api_key_service_quotas.remaining_quota - $3,
    updated_at = NOW()
FROM quota_check qc
WHERE api_key_service_quotas.id = qc.id
    AND qc.remaining_quota >= $3
RETURNING api_key_service_quotas.remaining_quota, api_key_service_quotas.initial_quota;

-- Refund $amount quota for ($api_key, $service_name) by (increases by $amount unit)
-- name: RefundQuota :one
WITH quota_update AS (
    SELECT aksq.id, aksq.remaining_quota, aksq.initial_quota
    FROM api_key_service_quotas aksq
    JOIN services s ON aksq.service_id = s.id
    JOIN api_keys ak ON aksq.api_key_id = ak.id
    WHERE ak.key_string = $1 AND s.name = $2 AND ak.status = 'assigned'
)
UPDATE api_key_service_quotas
SET remaining_quota = LEAST(api_key_service_quotas.remaining_quota + $3, qu.initial_quota),
    updated_at = NOW()
FROM quota_update qu
WHERE api_key_service_quotas.id = qu.id
RETURNING api_key_service_quotas.remaining_quota, api_key_service_quotas.initial_quota;

