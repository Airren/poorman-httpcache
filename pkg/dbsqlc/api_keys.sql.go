// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_keys.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignKeyToUser = `-- name: AssignKeyToUser :one
UPDATE api_keys 
SET user_id = $2, status = 'assigned', updated_at = NOW()
WHERE key_string = $1 AND status = 'unassigned'
RETURNING id, user_id, key_string, status, has_quota, created_at, updated_at
`

type AssignKeyToUserParams struct {
	KeyString string
	UserID    int64
}

// Assign key to user (update user_id and status in one go)
func (q *Queries) AssignKeyToUser(ctx context.Context, arg *AssignKeyToUserParams) (*ApiKeys, error) {
	row := q.db.QueryRow(ctx, assignKeyToUser, arg.KeyString, arg.UserID)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

type BatchCreateAPIKeysParams struct {
	UserID    int64
	KeyString string
	Status    string
	HasQuota  bool
}

const createServiceKey = `-- name: CreateServiceKey :one

INSERT INTO api_keys (user_id, key_string, status, has_quota)
VALUES ($1, $2, 'unassigned', FALSE)
RETURNING id, user_id, key_string, status, has_quota, created_at, updated_at
`

type CreateServiceKeyParams struct {
	UserID    int64
	KeyString string
}

// API Key-related queries
// Create service key with no quota (has_quota = false)
func (q *Queries) CreateServiceKey(ctx context.Context, arg *CreateServiceKeyParams) (*ApiKeys, error) {
	row := q.db.QueryRow(ctx, createServiceKey, arg.UserID, arg.KeyString)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUserAPIKey = `-- name: CreateUserAPIKey :one
INSERT INTO api_keys (user_id, key_string, status, has_quota)
VALUES ($1, $2, 'unassigned', TRUE)
RETURNING id, user_id, key_string, status, has_quota, created_at, updated_at
`

type CreateUserAPIKeyParams struct {
	UserID    int64
	KeyString string
}

// Create user API key with quota (has_quota = true)
func (q *Queries) CreateUserAPIKey(ctx context.Context, arg *CreateUserAPIKeyParams) (*ApiKeys, error) {
	row := q.db.QueryRow(ctx, createUserAPIKey, arg.UserID, arg.KeyString)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAPIKeyByKeyString = `-- name: GetAPIKeyByKeyString :one
SELECT id, key_string,has_quota, status FROM api_keys WHERE key_string = $1
`

type GetAPIKeyByKeyStringRow struct {
	ID        int64
	KeyString string
	HasQuota  bool
	Status    string
}

// Get API key info by key string (for quota checking)
func (q *Queries) GetAPIKeyByKeyString(ctx context.Context, keyString string) (*GetAPIKeyByKeyStringRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByKeyString, keyString)
	var i GetAPIKeyByKeyStringRow
	err := row.Scan(
		&i.ID,
		&i.KeyString,
		&i.HasQuota,
		&i.Status,
	)
	return &i, err
}

const getAPIKeyWithUser = `-- name: GetAPIKeyWithUser :one
SELECT ak.id, ak.user_id, ak.key_string, ak.status, ak.has_quota, ak.created_at, ak.updated_at, u.email as user_email
FROM api_keys ak
JOIN users u ON ak.user_id = u.id
WHERE ak.id = $1
`

type GetAPIKeyWithUserRow struct {
	ID        int64
	UserID    int64
	KeyString string
	Status    string
	HasQuota  bool
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	UserEmail string
}

// Get API key with user info
func (q *Queries) GetAPIKeyWithUser(ctx context.Context, id int64) (*GetAPIKeyWithUserRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyWithUser, id)
	var i GetAPIKeyWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserEmail,
	)
	return &i, err
}

const getAPIKeysByUserID = `-- name: GetAPIKeysByUserID :many
SELECT id, user_id, key_string, status, has_quota, created_at, updated_at FROM api_keys 
WHERE user_id = $1
ORDER BY created_at DESC
`

// Get all API keys for a user
func (q *Queries) GetAPIKeysByUserID(ctx context.Context, userID int64) ([]*ApiKeys, error) {
	rows, err := q.db.Query(ctx, getAPIKeysByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ApiKeys
	for rows.Next() {
		var i ApiKeys
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyString,
			&i.Status,
			&i.HasQuota,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAPIKeys = `-- name: GetAllAPIKeys :many
SELECT id, user_id, key_string, status, has_quota, created_at, updated_at FROM api_keys
ORDER BY created_at DESC
`

// Get all API keys
func (q *Queries) GetAllAPIKeys(ctx context.Context) ([]*ApiKeys, error) {
	rows, err := q.db.Query(ctx, getAllAPIKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ApiKeys
	for rows.Next() {
		var i ApiKeys
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyString,
			&i.Status,
			&i.HasQuota,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssignedAPIKeysByUserID = `-- name: GetAssignedAPIKeysByUserID :many
SELECT id, user_id, key_string, status, has_quota, created_at, updated_at FROM api_keys 
WHERE user_id = $1 AND status = 'assigned'
ORDER BY created_at DESC
`

// Get assigned API keys for a user
func (q *Queries) GetAssignedAPIKeysByUserID(ctx context.Context, userID int64) ([]*ApiKeys, error) {
	rows, err := q.db.Query(ctx, getAssignedAPIKeysByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ApiKeys
	for rows.Next() {
		var i ApiKeys
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyString,
			&i.Status,
			&i.HasQuota,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeyWithServicesForInitialization = `-- name: GetKeyWithServicesForInitialization :many
SELECT ak.id as api_key_id, s.id as service_id
FROM api_keys ak
CROSS JOIN services s
WHERE ak.id = $1
`

type GetKeyWithServicesForInitializationRow struct {
	ApiKeyID  int64
	ServiceID int64
}

// Get key with services for initialization workflow
func (q *Queries) GetKeyWithServicesForInitialization(ctx context.Context, id int64) ([]*GetKeyWithServicesForInitializationRow, error) {
	rows, err := q.db.Query(ctx, getKeyWithServicesForInitialization, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetKeyWithServicesForInitializationRow
	for rows.Next() {
		var i GetKeyWithServicesForInitializationRow
		if err := rows.Scan(&i.ApiKeyID, &i.ServiceID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnassignedKey = `-- name: GetUnassignedKey :one
SELECT id, user_id, key_string, status, has_quota, created_at, updated_at FROM api_keys 
WHERE status = 'unassigned' AND user_id = $1
LIMIT 1
`

// Find an unassigned key for a user
func (q *Queries) GetUnassignedKey(ctx context.Context, userID int64) (*ApiKeys, error) {
	row := q.db.QueryRow(ctx, getUnassignedKey, userID)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateAPIKeyStatus = `-- name: UpdateAPIKeyStatus :one
UPDATE api_keys 
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, key_string, status, has_quota, created_at, updated_at
`

type UpdateAPIKeyStatusParams struct {
	ID     int64
	Status string
}

// Update API key status
func (q *Queries) UpdateAPIKeyStatus(ctx context.Context, arg *UpdateAPIKeyStatusParams) (*ApiKeys, error) {
	row := q.db.QueryRow(ctx, updateAPIKeyStatus, arg.ID, arg.Status)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyString,
		&i.Status,
		&i.HasQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
