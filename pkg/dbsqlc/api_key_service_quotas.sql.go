// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_key_service_quotas.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchInitializeKeyQuotasParams struct {
	ApiKeyID     int64
	ServiceID    int64
	InitialQuota int32
}

const getAPIKeyQuotas = `-- name: GetAPIKeyQuotas :many
SELECT aksq.id, aksq.api_key_id, aksq.service_id, aksq.initial_quota, aksq.remaining_quota, aksq.created_at, aksq.updated_at, s.name as service_name
FROM api_key_service_quotas aksq
JOIN services s ON aksq.service_id = s.id
WHERE aksq.api_key_id = $1
`

type GetAPIKeyQuotasRow struct {
	ID             int64
	ApiKeyID       int64
	ServiceID      int64
	InitialQuota   int32
	RemainingQuota int32
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	ServiceName    string
}

// Get API key quotas with service info
func (q *Queries) GetAPIKeyQuotas(ctx context.Context, apiKeyID int64) ([]*GetAPIKeyQuotasRow, error) {
	rows, err := q.db.Query(ctx, getAPIKeyQuotas, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAPIKeyQuotasRow
	for rows.Next() {
		var i GetAPIKeyQuotasRow
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.ServiceID,
			&i.InitialQuota,
			&i.RemainingQuota,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceByID = `-- name: GetBalanceByID :one
SELECT aksq.initial_quota, aksq.remaining_quota
FROM api_key_service_quotas aksq
WHERE aksq.api_key_id = $1 and aksq.service_id = $2
`

type GetBalanceByIDParams struct {
	ApiKeyID  int64
	ServiceID int64
}

type GetBalanceByIDRow struct {
	InitialQuota   int32
	RemainingQuota int32
}

// Get balance (remaining quota) for an API key by key_string and service_id
func (q *Queries) GetBalanceByID(ctx context.Context, arg *GetBalanceByIDParams) (*GetBalanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getBalanceByID, arg.ApiKeyID, arg.ServiceID)
	var i GetBalanceByIDRow
	err := row.Scan(&i.InitialQuota, &i.RemainingQuota)
	return &i, err
}

const getQuota = `-- name: GetQuota :one
SELECT aksq.initial_quota, aksq.remaining_quota
FROM api_key_service_quotas aksq
JOIN services s ON aksq.service_id = s.id
JOIN api_keys ak ON aksq.api_key_id = ak.id
WHERE ak.key_string = $1 and s.name = $2
`

type GetQuotaParams struct {
	KeyString string
	Name      string
}

type GetQuotaRow struct {
	InitialQuota   int32
	RemainingQuota int32
}

// Get balance (remaining quota) for an API key by key_string and service_id
func (q *Queries) GetQuota(ctx context.Context, arg *GetQuotaParams) (*GetQuotaRow, error) {
	row := q.db.QueryRow(ctx, getQuota, arg.KeyString, arg.Name)
	var i GetQuotaRow
	err := row.Scan(&i.InitialQuota, &i.RemainingQuota)
	return &i, err
}

const initializeKeyServiceQuota = `-- name: InitializeKeyServiceQuota :one

INSERT INTO api_key_service_quotas (api_key_id, service_id, initial_quota, remaining_quota)
VALUES ($1, $2, $3, $3)
ON CONFLICT (api_key_id, service_id) DO UPDATE SET
    initial_quota = $3,
    remaining_quota = $3,
    updated_at = NOW()
RETURNING id, api_key_id, service_id, initial_quota, remaining_quota, created_at, updated_at
`

type InitializeKeyServiceQuotaParams struct {
	ApiKeyID     int64
	ServiceID    int64
	InitialQuota int32
}

// API Key Service Quota-related queries
// Initialize API key service quotas with full quota
func (q *Queries) InitializeKeyServiceQuota(ctx context.Context, arg *InitializeKeyServiceQuotaParams) (*ApiKeyServiceQuotas, error) {
	row := q.db.QueryRow(ctx, initializeKeyServiceQuota, arg.ApiKeyID, arg.ServiceID, arg.InitialQuota)
	var i ApiKeyServiceQuotas
	err := row.Scan(
		&i.ID,
		&i.ApiKeyID,
		&i.ServiceID,
		&i.InitialQuota,
		&i.RemainingQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const refundQuota = `-- name: RefundQuota :one
WITH quota_update AS (
    SELECT aksq.id, aksq.remaining_quota, aksq.initial_quota
    FROM api_key_service_quotas aksq
    JOIN services s ON aksq.service_id = s.id
    JOIN api_keys ak ON aksq.api_key_id = ak.id
    WHERE ak.key_string = $1 AND s.name = $2 AND ak.status = 'assigned'
)
UPDATE api_key_service_quotas
SET remaining_quota = LEAST(api_key_service_quotas.remaining_quota + $3, qu.initial_quota),
    updated_at = NOW()
FROM quota_update qu
WHERE api_key_service_quotas.id = qu.id
RETURNING api_key_service_quotas.remaining_quota, api_key_service_quotas.initial_quota
`

type RefundQuotaParams struct {
	KeyString      string
	Name           string
	RemainingQuota int32
}

type RefundQuotaRow struct {
	RemainingQuota int32
	InitialQuota   int32
}

// Refund $amount quota for ($api_key, $service_name) by (increases by $amount unit)
func (q *Queries) RefundQuota(ctx context.Context, arg *RefundQuotaParams) (*RefundQuotaRow, error) {
	row := q.db.QueryRow(ctx, refundQuota, arg.KeyString, arg.Name, arg.RemainingQuota)
	var i RefundQuotaRow
	err := row.Scan(&i.RemainingQuota, &i.InitialQuota)
	return &i, err
}

const reserveQuota = `-- name: ReserveQuota :one
WITH quota_check AS (
    SELECT aksq.id, aksq.remaining_quota, aksq.api_key_id, aksq.service_id
    FROM api_key_service_quotas aksq
    JOIN services s ON aksq.service_id = s.id
    JOIN api_keys ak ON aksq.api_key_id = ak.id
    WHERE ak.key_string = $1 AND s.name = $2 AND ak.status = 'assigned'
)
UPDATE api_key_service_quotas
SET remaining_quota = api_key_service_quotas.remaining_quota - $3,
    updated_at = NOW()
FROM quota_check qc
WHERE api_key_service_quotas.id = qc.id
    AND qc.remaining_quota >= $3
RETURNING api_key_service_quotas.remaining_quota, api_key_service_quotas.initial_quota
`

type ReserveQuotaParams struct {
	KeyString      string
	Name           string
	RemainingQuota int32
}

type ReserveQuotaRow struct {
	RemainingQuota int32
	InitialQuota   int32
}

// Reserve $amount quota for ($api_key, $service_name) by  (decreases by $amount unit)
func (q *Queries) ReserveQuota(ctx context.Context, arg *ReserveQuotaParams) (*ReserveQuotaRow, error) {
	row := q.db.QueryRow(ctx, reserveQuota, arg.KeyString, arg.Name, arg.RemainingQuota)
	var i ReserveQuotaRow
	err := row.Scan(&i.RemainingQuota, &i.InitialQuota)
	return &i, err
}
