// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_key_service_quotas.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchInitializeKeyQuotasParams struct {
	ApiKeyID     int64
	ServiceID    int64
	InitialQuota int32
}

const consumeQuotaByKeyString = `-- name: ConsumeQuotaByKeyString :one
WITH updated AS (
    UPDATE api_key_service_quotas
    SET remaining_quota = remaining_quota - 1,
        updated_at = NOW()
    FROM api_keys ak
    WHERE api_key_service_quotas.api_key_id = ak.id
      AND ak.key_string = $1
      AND ak.status = 'assigned'
      AND api_key_service_quotas.remaining_quota > 0
    RETURNING api_key_service_quotas.api_key_id, api_key_service_quotas.remaining_quota
)
SELECT COALESCE(SUM(aksq.remaining_quota), 0)::INT as total_balance
FROM api_key_service_quotas aksq
JOIN api_keys ak ON aksq.api_key_id = ak.id
WHERE ak.key_string = $1 AND ak.status = 'assigned'
`

// Consume quota for an API key by key_string (decreases by 1 unit)
func (q *Queries) ConsumeQuotaByKeyString(ctx context.Context, keyString string) (int32, error) {
	row := q.db.QueryRow(ctx, consumeQuotaByKeyString, keyString)
	var total_balance int32
	err := row.Scan(&total_balance)
	return total_balance, err
}

const getAPIKeyQuotas = `-- name: GetAPIKeyQuotas :many
SELECT aksq.id, aksq.api_key_id, aksq.service_id, aksq.initial_quota, aksq.remaining_quota, aksq.created_at, aksq.updated_at, s.name as service_name
FROM api_key_service_quotas aksq
JOIN services s ON aksq.service_id = s.id
WHERE aksq.api_key_id = $1
`

type GetAPIKeyQuotasRow struct {
	ID             int64
	ApiKeyID       int64
	ServiceID      int64
	InitialQuota   int32
	RemainingQuota int32
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	ServiceName    string
}

// Get API key quotas with service info
func (q *Queries) GetAPIKeyQuotas(ctx context.Context, apiKeyID int64) ([]*GetAPIKeyQuotasRow, error) {
	rows, err := q.db.Query(ctx, getAPIKeyQuotas, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAPIKeyQuotasRow
	for rows.Next() {
		var i GetAPIKeyQuotasRow
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.ServiceID,
			&i.InitialQuota,
			&i.RemainingQuota,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceByKeyString = `-- name: GetBalanceByKeyString :one
SELECT COALESCE(SUM(aksq.remaining_quota), 0)::INT as total_balance
FROM api_key_service_quotas aksq
JOIN api_keys ak ON aksq.api_key_id = ak.id
WHERE ak.key_string = $1 AND ak.status = 'assigned'
`

// Get balance (remaining quota) for an API key by key_string
func (q *Queries) GetBalanceByKeyString(ctx context.Context, keyString string) (int32, error) {
	row := q.db.QueryRow(ctx, getBalanceByKeyString, keyString)
	var total_balance int32
	err := row.Scan(&total_balance)
	return total_balance, err
}

const initializeKeyServiceQuota = `-- name: InitializeKeyServiceQuota :one

INSERT INTO api_key_service_quotas (api_key_id, service_id, initial_quota, remaining_quota)
VALUES ($1, $2, $3, $3)
ON CONFLICT (api_key_id, service_id) DO UPDATE SET
    initial_quota = $3,
    remaining_quota = $3,
    updated_at = NOW()
RETURNING id, api_key_id, service_id, initial_quota, remaining_quota, created_at, updated_at
`

type InitializeKeyServiceQuotaParams struct {
	ApiKeyID     int64
	ServiceID    int64
	InitialQuota int32
}

// API Key Service Quota-related queries
// Initialize API key service quotas with full quota
func (q *Queries) InitializeKeyServiceQuota(ctx context.Context, arg *InitializeKeyServiceQuotaParams) (*ApiKeyServiceQuotas, error) {
	row := q.db.QueryRow(ctx, initializeKeyServiceQuota, arg.ApiKeyID, arg.ServiceID, arg.InitialQuota)
	var i ApiKeyServiceQuotas
	err := row.Scan(
		&i.ID,
		&i.ApiKeyID,
		&i.ServiceID,
		&i.InitialQuota,
		&i.RemainingQuota,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
